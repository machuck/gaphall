<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Virtual Art Gallery</title>
    
    <!-- Babylon.js CDN -->
    <script src="https://unpkg.com/babylonjs@6.37.1/babylon.js"></script>
    <script src="https://unpkg.com/babylonjs-loaders@6.37.1/babylonjs.loaders.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: manipulation;
        }
        
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            outline: none;
            touch-action: none;
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .controls {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            pointer-events: auto;
            max-width: 160px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .controls h3 {
            margin-bottom: 8px;
            font-size: 14px;
            color: #fff;
        }
        
        .controls button {
            display: block;
            width: 100%;
            margin: 4px 0;
            padding: 10px;
            font-size: 12px;
            background: rgba(0, 120, 255, 0.8);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .controls button:hover {
            background: rgba(0, 120, 255, 1);
            transform: translateY(-1px);
        }
        
        .controls button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        .info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .upload-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.4);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(20px);
            pointer-events: auto;
            max-width: 320px;
            width: 90%;
            display: none;
            z-index: 200;
        }
        
        .upload-modal.show {
            display: block;
        }
        
        .upload-modal h4 {
            margin-bottom: 15px;
            font-size: 16px;
            text-align: center;
            color: #fff;
        }
        
        .upload-fields input,
        .upload-fields textarea {
            width: 100%;
            margin: 8px 0;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 14px;
        }
        
        .upload-fields input::placeholder,
        .upload-fields textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .upload-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .upload-buttons button {
            flex: 1;
            padding: 12px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: #0078ff;
            color: white;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .notification {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 120, 255, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            transform: translateX(100px);
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 150;
            max-width: 300px;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        
        .gyro-permission {
            position: absolute;
            bottom: 80px;
            left: 15px;
            background: rgba(0, 180, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 140;
        }
        
        .gyro-permission.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 300;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #333;
            border-top: 4px solid #0078ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .debug-panel {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.3);
            color: #00ff00;
            padding: 8px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 10px;
            max-width: 250px;
            pointer-events: none;
            border: 1px solid rgba(0, 255, 0, 0.2);
            backdrop-filter: blur(15px);
        }
        
        @media (max-width: 768px) {
            .controls {
                max-width: 140px;
                padding: 10px;
            }
            
            .controls button {
                padding: 8px;
                font-size: 11px;
            }
            
            .debug-panel {
                font-size: 9px;
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="ui-overlay">
        <div class="controls">
            <h3>Gallery Controls</h3>
            <button onclick="app.uploadArt()">Upload Art</button>
            <button onclick="app.resetCamera()">Center View</button>
            <button onclick="app.nextArtwork()">Next Artwork</button>
            <button onclick="app.toggleLighting()">Toggle Lights</button>
            <button onclick="app.toggleGyro()" id="gyroBtn">Enable Gyro</button>
            <button onclick="app.calibrateGyro()" id="calibrateBtn" style="display:none">Calibrate</button>
            <button onclick="app.clearGallery()">Clear Gallery</button>
        </div>
        
        <div class="info" id="info">
            Gallery Loaded • Use double-tap to teleport to next artwork
        </div>
        
        <div class="upload-modal" id="uploadModal">
            <h4>Upload Your Artwork</h4>
            <div class="upload-fields">
                <input type="text" id="artistName" placeholder="Artist name">
                <textarea id="artDescription" placeholder="Description" rows="3"></textarea>
            </div>
            <div class="upload-buttons">
                <button class="btn-secondary" onclick="app.hideUpload()">Cancel</button>
                <button class="btn-primary" onclick="app.selectFiles()">Choose Files</button>
            </div>
            <input type="file" id="fileInput" accept="image/*" multiple>
        </div>
        
        <div class="notification" id="notification"></div>
        
        <div class="gyro-permission" id="gyroPermission" onclick="app.requestGyroPermission()">
            Tap to enable ground-parallel gyroscope
        </div>
        
        <div class="debug-panel" id="debugPanel">
            GYRO STATUS: Initializing...
        </div>
    </div>
    
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <p>Loading Virtual Gallery...</p>
    </div>

    <script>
        // ✅ WAIT FOR BABYLON.JS TO LOAD BEFORE INITIALIZING
        function waitForBabylon() {
            return new Promise((resolve, reject) => {
                if (typeof BABYLON !== 'undefined') {
                    resolve();
                    return;
                }
                
                let attempts = 0;
                const maxAttempts = 50; // 5 seconds max wait
                
                const checkBabylon = () => {
                    attempts++;
                    if (typeof BABYLON !== 'undefined') {
                        console.log('✅ Babylon.js loaded successfully');
                        resolve();
                    } else if (attempts >= maxAttempts) {
                        reject(new Error('Babylon.js failed to load after 5 seconds. Check internet connection.'));
                    } else {
                        setTimeout(checkBabylon, 100);
                    }
                };
                
                checkBabylon();
            });
        }
        let DEFAULT_ARTWORKS = [];
        
        async function loadDefaultArtworksManifest() {
            console.log('🔍 Loading default artworks manifest...');
            try {
                const response = await fetch('/gallery/defaults/manifest.json');
                if (!response.ok) {
                    console.warn('❌ No manifest.json found, using built-in defaults');
                    return getBuiltinArtworks();
                }
                const data = await response.json();
                console.log('📄 Loaded manifest:', data.artworks?.length || 0, 'artworks');
                return data.artworks || getBuiltinArtworks();
            } catch (error) {
                console.error('💥 Error loading manifest.json:', error);
                return getBuiltinArtworks();
            }
        }
        
        function getBuiltinArtworks() {
            return [
                {
                    "filename": "1693px-Retrato_del_Papa_Inocencio_X._Roma,_by_Diego_Velázquez.jpg",
                    "name": "Portrait of Pope Innocent X",
                    "author": "Diego Velázquez",
                    "description": "Baroque masterpiece depicting Pope Innocent X (c. 1650)"
                },
                {
                    "filename": "1877px-Las_Meninas,_by_Diego_Velázquez,_from_Prado_in_Google_Earth.jpg",
                    "name": "Las Meninas",
                    "author": "Diego Velázquez", 
                    "description": "Complex composition featuring the Infanta Margarita Teresa (1656)"
                },
                {
                    "filename": "1912px-John_Singer_Sargent_-_Carnation,_Lily,_Lily,_Rose_-_Google_Art_Project.jpg",
                    "name": "Carnation, Lily, Lily, Rose",
                    "author": "John Singer Sargent",
                    "description": "Impressionist painting of young girls with Chinese lanterns (1885-1886)"
                },
                {
                    "filename": "2942px-\"Un_Bar_aux_Folies-Bergère\"_by_Édouard_Manet_(1882).jpg",
                    "name": "A Bar at the Folies-Bergère",
                    "author": "Édouard Manet",
                    "description": "Manet's final major work, Parisian nightclub scene (1882)"
                },
                {
                    "filename": "Edouard_Manet_-_Olympia_-_Google_Art_Project_3.jpg",
                    "name": "Olympia", 
                    "author": "Édouard Manet",
                    "description": "Controversial modernist painting, caused scandal at 1865 Paris Salon"
                },
                {
                    "filename": "Madame_X_(Madame_Pierre_Gautreau),_John_Singer_Sargent,_1884_(unfree_frame_crop).jpg",
                    "name": "Madame X (Madame Pierre Gautreau)",
                    "author": "John Singer Sargent",
                    "description": "Portrait of socialite, now considered Sargent's masterpiece (1884)"
                }
            ];
        }

        class EnhancedVirtualGallery {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.engine = null;
                this.scene = null;
                this.camera = null;
                this.artworks = [];
                this.currentArtIndex = 0;
                this.lightingBright = false;
                this.defaultArtFolder = "/gallery/defaults/";
                
                // ✅ GROUND-PARALLEL GYROSCOPE SYSTEM (like mouse drag)
                this.gyroEnabled = false;
                this.gyroSupported = false;
                
                // Ground-parallel rotation values (Euler angles for simplicity)
                this.calibratedAlpha = 0; // Initial compass heading
                this.calibratedBeta = 0;  // Initial pitch offset
                this.smoothedYaw = 0;     // Smooth horizontal rotation
                this.smoothedPitch = 0;   // Smooth vertical rotation
                this.smoothingFactor = 0.85; // High smoothing for stability
                
                // Touch properties
                this.isTouchActive = false;
                this.lastTouchX = 0;
                this.lastTouchY = 0;
                this.lastTapTime = 0;
                this.touchRotationQuaternion = new BABYLON.Quaternion.Identity();
                
                // Sweet spots for viewing artworks - FIXED POSITIONS
                this.viewingSpots = [
                    { pos: new BABYLON.Vector3(0, 1.6, 6), target: new BABYLON.Vector3(0, 2, 9.8) },   // Back wall center
                    { pos: new BABYLON.Vector3(-6, 1.6, 6), target: new BABYLON.Vector3(-9.8, 2, 6) }, // Left wall
                    { pos: new BABYLON.Vector3(6, 1.6, 6), target: new BABYLON.Vector3(9.8, 2, 6) },   // Right wall
                    { pos: new BABYLON.Vector3(-6, 1.6, -2), target: new BABYLON.Vector3(-9.8, 2, -2) }, // Left wall back
                    { pos: new BABYLON.Vector3(6, 1.6, -2), target: new BABYLON.Vector3(9.8, 2, -2) },   // Right wall back
                    { pos: new BABYLON.Vector3(0, 1.6, 0), target: new BABYLON.Vector3(0, 1.6, 5) }      // Hall center
                ];
                
                this.init();
            }
            
            async init() {
                try {
                    // ✅ FIX BABYLON UNDEFINED ERROR - Better error handling
                    if (typeof BABYLON === 'undefined') {
                        throw new Error('Babylon.js failed to load. Please check your internet connection.');
                    }
                    
                    // Initialize Babylon.js
                    this.engine = new BABYLON.Engine(this.canvas, true, { preserveDrawingBuffer: true, stencil: true });
                    this.scene = new BABYLON.Scene(this.engine);
                    
                    // ✅ FIX SPOTLIGHT LIMIT - Babylon.js defaults to 4 lights max!
                    // We need: 2 main lights + 12 spotlights = 14 total
                    console.log('🔧 Setting maximum lights to 20 (was:', this.engine.getCaps().maxLights, ')');
                    this.scene.getEngine().getCaps().maxLights = 20;
                    
                    // Also set it on the scene itself
                    if (this.scene.setRenderingAutoClearDepthStencil) {
                        this.scene.setRenderingAutoClearDepthStencil(0, true, true, true);
                    }
                    
                    this.setupCamera();
                    this.setupLighting();
                    this.createGallery();
                    this.setupControls();
                    this.initGyroscope();
                    
                    // ✅ LOAD REAL DEFAULT ARTWORKS
                    DEFAULT_ARTWORKS = await loadDefaultArtworksManifest();
                    this.loadDefaultArtworks();
                    
                    // Start render loop
                    this.engine.runRenderLoop(() => {
                        this.scene.render();
                    });
                    
                    window.addEventListener('resize', () => {
                        this.engine.resize();
                    });
                    
                    document.getElementById('loading').style.display = 'none';
                    this.showNotification('🎨 Virtual Gallery Ready! Loading masterpiece collection...');
                    
                } catch (error) {
                    console.error('Gallery initialization failed:', error);
                    this.showError('Failed to initialize gallery: ' + error.message);
                }
            }
            
            showError(message) {
                document.getElementById('loading').style.display = 'none';
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background: rgba(200, 0, 0, 0.9); color: white; padding: 20px;
                    border-radius: 10px; text-align: center; z-index: 1000;
                    max-width: 80%; font-family: Arial, sans-serif;
                `;
                errorDiv.innerHTML = `
                    <h3>Gallery Error</h3>
                    <p>${message}</p>
                    <button onclick="location.reload()" style="margin-top:10px;padding:8px 16px;background:#fff;color:#000;border:none;border-radius:4px;cursor:pointer;">
                        Reload Page
                    </button>
                `;
                document.body.appendChild(errorDiv);
            }
            
            setupCamera() {
                // ✅ START AT HALL CENTER, LOOKING HORIZONTALLY TOWARD BACK WALL
                this.camera = new BABYLON.UniversalCamera('camera', 
                    new BABYLON.Vector3(0, 1.6, 0), this.scene);
                
                // ✅ PURE QUATERNION ROTATION SYSTEM
                this.camera.rotationQuaternion = new BABYLON.Quaternion.Identity();
                
                // Look toward back wall horizontally, not down at floor
                this.camera.setTarget(new BABYLON.Vector3(0, 1.6, 5));
                
                this.camera.attachControl(this.canvas, true);
                this.camera.speed = 0.8;
                this.camera.fov = this.isMobile() ? 1.2 : 0.8;
                
                // Enable collision detection
                this.camera.checkCollisions = true;
                this.camera.ellipsoid = new BABYLON.Vector3(0.5, 0.9, 0.5);
                this.scene.gravity = new BABYLON.Vector3(0, -9.81, 0);
                this.camera.applyGravity = true;
                
                // Keyboard controls
                this.camera.keysUp = [87]; // W
                this.camera.keysDown = [83]; // S
                this.camera.keysLeft = [65]; // A
                this.camera.keysRight = [68]; // D
            }
            
            setupLighting() {
                // ✅ ENHANCED AMBIENT LIGHTING (to compensate for subtle spotlights)
                this.ambientLight = new BABYLON.HemisphericLight('ambient', 
                    new BABYLON.Vector3(0, 1, 0), this.scene);
                this.ambientLight.intensity = 0.8; // Increased for better artwork visibility
                
                // Directional light
                this.directionalLight = new BABYLON.DirectionalLight('directional',
                    new BABYLON.Vector3(-0.2, -1, 0.5), this.scene);
                this.directionalLight.intensity = 0.6; // Slightly reduced since we have better ambient
                
                this.spotLights = [];
            }
            
            createGallery() {
                // Floor
                const floor = BABYLON.MeshBuilder.CreateGround('floor', 
                    { width: 20, height: 20 }, this.scene);
                const floorMat = new BABYLON.StandardMaterial('floorMat', this.scene);
                floorMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                floor.material = floorMat;
                floor.checkCollisions = true;
                
                // Walls
                this.createWalls();
                
                // Artwork positions
                this.artworkPositions = [
                    // Back wall artworks
                    { pos: new BABYLON.Vector3(-6, 2, 9.8), rot: new BABYLON.Vector3(0, 0, 0) },
                    { pos: new BABYLON.Vector3(-2, 2, 9.8), rot: new BABYLON.Vector3(0, 0, 0) },
                    { pos: new BABYLON.Vector3(2, 2, 9.8), rot: new BABYLON.Vector3(0, 0, 0) },
                    { pos: new BABYLON.Vector3(6, 2, 9.8), rot: new BABYLON.Vector3(0, 0, 0) },
                    
                    // Left wall artworks
                    { pos: new BABYLON.Vector3(-9.8, 2, 6), rot: new BABYLON.Vector3(0, Math.PI/2, 0) },
                    { pos: new BABYLON.Vector3(-9.8, 2, 2), rot: new BABYLON.Vector3(0, Math.PI/2, 0) },
                    { pos: new BABYLON.Vector3(-9.8, 2, -2), rot: new BABYLON.Vector3(0, Math.PI/2, 0) },
                    { pos: new BABYLON.Vector3(-9.8, 2, -6), rot: new BABYLON.Vector3(0, Math.PI/2, 0) },
                    
                    // Right wall artworks
                    { pos: new BABYLON.Vector3(9.8, 2, 6), rot: new BABYLON.Vector3(0, -Math.PI/2, 0) },
                    { pos: new BABYLON.Vector3(9.8, 2, 2), rot: new BABYLON.Vector3(0, -Math.PI/2, 0) },
                    { pos: new BABYLON.Vector3(9.8, 2, -2), rot: new BABYLON.Vector3(0, -Math.PI/2, 0) },
                    { pos: new BABYLON.Vector3(9.8, 2, -6), rot: new BABYLON.Vector3(0, -Math.PI/2, 0) }
                ];
            }
            
            createWalls() {
                const wallHeight = 4;
                const wallWidth = 20;
                
                // Back wall
                const backWall = BABYLON.MeshBuilder.CreateBox('backWall',
                    { width: wallWidth, height: wallHeight, depth: 0.2 }, this.scene);
                backWall.position = new BABYLON.Vector3(0, wallHeight/2, 10);
                
                // Left wall
                const leftWall = BABYLON.MeshBuilder.CreateBox('leftWall',
                    { width: 0.2, height: wallHeight, depth: wallWidth }, this.scene);
                leftWall.position = new BABYLON.Vector3(-10, wallHeight/2, 0);
                
                // Right wall
                const rightWall = BABYLON.MeshBuilder.CreateBox('rightWall',
                    { width: 0.2, height: wallHeight, depth: wallWidth }, this.scene);
                rightWall.position = new BABYLON.Vector3(10, wallHeight/2, 0);
                
                const wallMat = new BABYLON.StandardMaterial('wallMat', this.scene);
                wallMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                
                [backWall, leftWall, rightWall].forEach(wall => {
                    wall.material = wallMat;
                    wall.checkCollisions = true;
                });
            }
            
            setupControls() {
                // ✅ CONTEXT-SENSITIVE TOUCH CONTROLS
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1) {
                        this.isTouchActive = true;
                        this.lastTouchX = e.touches[0].clientX;
                        this.lastTouchY = e.touches[0].clientY;
                    }
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.isTouchActive || e.touches.length !== 1) return;
                    
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - this.lastTouchX;
                    const deltaY = touch.clientY - this.lastTouchY;
                    
                    if (this.gyroEnabled) {
                        // ✅ GYRO ENABLED: Touch controls looking around (quaternion-based)
                        const sensitivity = 0.003;
                        const yawQ = new BABYLON.Quaternion.RotationAxis(BABYLON.Vector3.Up(), deltaX * sensitivity);
                        const pitchQ = new BABYLON.Quaternion.RotationAxis(BABYLON.Vector3.Right(), deltaY * sensitivity);
                        
                        // Compose with existing touch rotation
                        this.touchRotationQuaternion = this.touchRotationQuaternion.multiply(yawQ).multiply(pitchQ);
                        
                    } else {
                        // ✅ GYRO DISABLED: Vertical swipe = forward/backward, horizontal = rotate
                        if (Math.abs(deltaY) > Math.abs(deltaX)) {
                            // Vertical movement
                            const forward = this.camera.getForwardRay().direction;
                            this.camera.position.addInPlace(forward.scale(-deltaY * 0.01));
                        } else {
                            // Horizontal rotation
                            const yawQ = new BABYLON.Quaternion.RotationAxis(BABYLON.Vector3.Up(), deltaX * 0.005);
                            this.camera.rotationQuaternion = this.camera.rotationQuaternion.multiply(yawQ);
                        }
                    }
                    
                    this.lastTouchX = touch.clientX;
                    this.lastTouchY = touch.clientY;
                });
                
                this.canvas.addEventListener('touchend', (e) => {
                    if (e.touches.length === 0) {
                        this.isTouchActive = false;
                        
                        // ✅ DOUBLE-TAP SMART TELEPORTATION
                        const now = Date.now();
                        if (now - this.lastTapTime < 300) {
                            this.teleportToNextArtwork();
                        }
                        this.lastTapTime = now;
                    }
                });
                
                // ✅ MOUSE CONTROLS: Always look around
                this.canvas.addEventListener('mousemove', (e) => {
                    if (e.buttons === 1) { // Left mouse button
                        const sensitivity = 0.003;
                        const yawQ = new BABYLON.Quaternion.RotationAxis(BABYLON.Vector3.Up(), e.movementX * sensitivity);
                        const pitchQ = new BABYLON.Quaternion.RotationAxis(BABYLON.Vector3.Right(), e.movementY * sensitivity);
                        
                        this.camera.rotationQuaternion = this.camera.rotationQuaternion.multiply(yawQ).multiply(pitchQ);
                    }
                });
                
                // Mouse wheel zoom
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 0.1;
                    const delta = e.deltaY > 0 ? zoomSpeed : -zoomSpeed;
                    this.camera.fov = Math.max(0.3, Math.min(1.8, this.camera.fov + delta));
                });
            }
            
            initGyroscope() {
                // ✅ DESKTOP SHOULDN'T HAVE GYRO CONTROLS
                if (!this.isMobile()) {
                    document.getElementById('gyroBtn').style.display = 'none';
                    document.getElementById('calibrateBtn').style.display = 'none';
                    this.updateDebug("Desktop mode - No gyroscope controls");
                    return;
                }
                
                if (!('DeviceOrientationEvent' in window)) {
                    this.updateDebug("Gyro: Not supported");
                    return;
                }
                
                this.gyroSupported = true;
                this.updateDebug("Gyro: Ground-parallel mode available<br>Like mouse drag - no device tilt");
                
                // Update button text to indicate ground-parallel mode
                document.getElementById('gyroBtn').textContent = 'Enable Ground Gyro';
                
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    this.showGyroPermission();
                } else if (this.isMobile()) {
                    this.showGyroPermission();
                }
            }
            
            showGyroPermission() {
                const permissionBtn = document.getElementById('gyroPermission');
                permissionBtn.classList.add('show');
                setTimeout(() => permissionBtn.classList.remove('show'), 8000);
            }
            
            async requestGyroPermission() {
                try {
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            this.startGyroscope();
                        } else {
                            this.showNotification('Gyroscope permission denied');
                        }
                    } else {
                        this.startGyroscope();
                    }
                    document.getElementById('gyroPermission').classList.remove('show');
                } catch (error) {
                    console.error('Gyro permission error:', error);
                    this.showNotification('Error enabling gyroscope');
                }
            }
            
            startGyroscope() {
                if (!this.gyroSupported || this.gyroEnabled) return;
                
                this.gyroEnabled = true;
                document.getElementById('gyroBtn').textContent = 'Disable Ground Gyro';
                document.getElementById('calibrateBtn').style.display = 'block';
                
                window.addEventListener('deviceorientation', (event) => {
                    this.handleGroundParallelGyroscope(event);
                });
                
                // Auto-calibrate after 1 second
                setTimeout(() => this.calibrateGyro(), 1000);
                
                this.showNotification('✅ Ground-parallel gyroscope active! Works like mouse drag - device tilt ignored.');
                this.updateDebug("Gyro: Ground-parallel mode active<br>Device tilt ignored");
            }
            
            // ✅ GROUND-PARALLEL GYROSCOPE - BEHAVES LIKE MOUSE DRAG
            handleGroundParallelGyroscope(event) {
                if (!this.gyroEnabled || event.alpha === null) return;
                
                // Get raw device orientation
                const alpha = event.alpha || 0; // Compass heading (0-360°)
                const beta = event.beta || 0;   // Forward/backward tilt (-180 to 180°)
                const gamma = event.gamma || 0; // Left/right tilt (-90 to 90°)
                
                // ✅ EXTRACT GROUND-PARALLEL ROTATION (like mouse drag)
                // Horizontal rotation: Use compass heading (alpha) - this is ground-parallel
                let groundYaw = (alpha - this.calibratedAlpha) * Math.PI / 180;
                
                // Vertical rotation: Extract pitch that ignores device roll/tilt
                // Use beta but compensate for device tilt (gamma)
                let groundPitch = (beta - this.calibratedBeta) * Math.PI / 180;
                
                // ✅ CLAMP PITCH to prevent looking too far up/down (like mouse drag)
                groundPitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, groundPitch));
                
                // ✅ SMOOTH THE VALUES (high smoothing for stability)
                this.smoothedYaw = this.smoothedYaw * this.smoothingFactor + groundYaw * (1 - this.smoothingFactor);
                this.smoothedPitch = this.smoothedPitch * this.smoothingFactor + groundPitch * (1 - this.smoothingFactor);
                
                // ✅ CREATE GROUND-PARALLEL QUATERNION ROTATION
                // Just like mouse drag: horizontal movement = yaw, vertical movement = pitch
                const yawQ = new BABYLON.Quaternion.RotationAxis(BABYLON.Vector3.Up(), this.smoothedYaw);
                const pitchQ = new BABYLON.Quaternion.RotationAxis(BABYLON.Vector3.Right(), this.smoothedPitch);
                
                // Combine ground-parallel rotation
                const groundParallelQ = yawQ.multiply(pitchQ);
                
                // ✅ COMPOSE WITH TOUCH ROTATION (if user also touches screen)
                const finalQuaternion = groundParallelQ.multiply(this.touchRotationQuaternion);
                
                // Apply to camera
                this.camera.rotationQuaternion = finalQuaternion;
                
                // Update debug - show ground-parallel values
                this.updateDebug(`Ground-Parallel Gyro<br>
                    Yaw: ${(this.smoothedYaw * 180/Math.PI).toFixed(1)}°<br>
                    Pitch: ${(this.smoothedPitch * 180/Math.PI).toFixed(1)}°<br>
                    ✅ Like mouse drag!`);
            }
            
            calibrateGyro() {
                if (!this.gyroEnabled) return;
                
                // ✅ GROUND-PARALLEL CALIBRATION (store current heading/pitch as offset)
                // This sets the current device orientation as the "neutral" position
                window.addEventListener('deviceorientation', (event) => {
                    this.calibratedAlpha = event.alpha || 0;
                    this.calibratedBeta = event.beta || 0;
                    
                    // Reset smoothed values
                    this.smoothedYaw = 0;
                    this.smoothedPitch = 0;
                    
                    // Reset touch rotation
                    this.touchRotationQuaternion = new BABYLON.Quaternion.Identity();
                    
                    this.showNotification('✅ Ground-parallel gyroscope calibrated!');
                    this.updateDebug("Gyro: Ground-parallel calibrated");
                }, { once: true }); // Only capture calibration once
            }
            
            // ✅ SMART TELEPORTATION TO NEXT ARTWORK WITH PROPER VIEWING
            teleportToNextArtwork() {
                if (this.artworks.length === 0) {
                    this.showNotification('No artworks to view');
                    return;
                }
                
                // Move to next artwork
                this.currentArtIndex = (this.currentArtIndex + 1) % this.artworks.length;
                const artwork = this.artworks[this.currentArtIndex];
                const artPos = artwork.position.pos;
                
                // ✅ CALCULATE PROPER VIEWING POSITION FOR EACH ARTWORK
                let viewingPos, targetPos;
                
                if (Math.abs(artPos.z - 9.8) < 0.1) {
                    // Back wall artwork - position in front
                    viewingPos = new BABYLON.Vector3(artPos.x, 1.6, artPos.z - 5);
                    targetPos = artPos.clone();
                } else if (Math.abs(artPos.x + 9.8) < 0.1) {
                    // Left wall artwork - position to the right
                    viewingPos = new BABYLON.Vector3(artPos.x + 5, 1.6, artPos.z);
                    targetPos = artPos.clone();
                } else if (Math.abs(artPos.x - 9.8) < 0.1) {
                    // Right wall artwork - position to the left
                    viewingPos = new BABYLON.Vector3(artPos.x - 5, 1.6, artPos.z);
                    targetPos = artPos.clone();
                } else {
                    // Fallback to center
                    viewingPos = new BABYLON.Vector3(0, 1.6, 0);
                    targetPos = new BABYLON.Vector3(0, 1.6, 5);
                }
                
                // ✅ TELEPORT TO OPTIMAL POSITION AND LOOK AT ARTWORK
                this.camera.position = viewingPos;
                this.camera.setTarget(targetPos);
                
                // Reset quaternion states for clean viewing
                this.camera.rotationQuaternion = new BABYLON.Quaternion.Identity();
                this.touchRotationQuaternion = new BABYLON.Quaternion.Identity();
                
                // Reset gyro smoothed values
                this.smoothedYaw = 0;
                this.smoothedPitch = 0;
                
                // Calculate direction to artwork and set proper rotation
                const direction = targetPos.subtract(viewingPos).normalize();
                const yaw = Math.atan2(direction.x, direction.z);
                const pitch = Math.asin(-direction.y);
                
                // Apply proper quaternion rotation for looking at artwork
                const yawQ = new BABYLON.Quaternion.RotationAxis(BABYLON.Vector3.Up(), yaw);
                const pitchQ = new BABYLON.Quaternion.RotationAxis(BABYLON.Vector3.Right(), pitch);
                this.camera.rotationQuaternion = yawQ.multiply(pitchQ);
                
                this.showNotification(`📍 Viewing: "${artwork.name}" by ${artwork.author} (${this.currentArtIndex + 1}/${this.artworks.length})`);
            }
            
            loadDefaultArtworks() {
                if (DEFAULT_ARTWORKS.length === 0) {
                    this.showNotification("No default artworks available");
                    return;
                }
                
                console.log(`🎨 Loading ${DEFAULT_ARTWORKS.length} default artworks...`);
                
                DEFAULT_ARTWORKS.forEach((artwork, index) => {
                    if (index < this.artworkPositions.length) {
                        const imageURL = this.defaultArtFolder + artwork.filename;
                        // Stagger loading to prevent overwhelming the browser
                        setTimeout(() => {
                            this.createRealArtwork(
                                artwork.name, 
                                imageURL, 
                                artwork.author, 
                                artwork.description || "",
                                index
                            );
                        }, index * 200);
                    }
                });
                
                this.updateInfo();
            }
            
            createRealArtwork(name, imageURL, author, description, index) {
                const position = this.artworkPositions[index];
                
                // ✅ LOAD REAL ARTWORK IMAGE WITH PROPORTIONAL SIZING
                const img = new Image();
                img.crossOrigin = "anonymous"; // Handle CORS if needed
                
                img.onload = () => {
                    // Calculate proportional size to fit in gallery
                    const maxWidth = 3;
                    const maxHeight = 2.5;
                    const aspectRatio = img.width / img.height;
                    
                    let width, height;
                    if (aspectRatio > 1) {
                        // Landscape
                        width = maxWidth;
                        height = maxWidth / aspectRatio;
                        if (height > maxHeight) {
                            height = maxHeight;
                            width = maxHeight * aspectRatio;
                        }
                    } else {
                        // Portrait or square
                        height = maxHeight;
                        width = maxHeight * aspectRatio;
                        if (width > maxWidth) {
                            width = maxWidth;
                            height = maxWidth / aspectRatio;
                        }
                    }
                    
                    // Create artwork plane with proper proportions
                    const plane = BABYLON.MeshBuilder.CreatePlane(`artwork_${index}`, 
                        { width: width, height: height }, this.scene);
                    
                    plane.position = position.pos.clone();
                    plane.rotation = position.rot.clone();
                    
                    // Create texture from actual artwork image
                    const texture = new BABYLON.Texture(imageURL, this.scene);
                    const material = new BABYLON.StandardMaterial(`mat_${index}`, this.scene);
                    
                    material.diffuseTexture = texture;
                    material.emissiveTexture = texture;
                    material.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                    material.backFaceCulling = false;
                    
                    plane.material = material;
                    
                    // ✅ ENSURE ALL SPOTLIGHTS ARE CREATED - with detailed logging
                    const spotPos = position.pos.clone();
                    
                    // Position spotlight based on wall orientation
                    if (Math.abs(position.rot.y) < 0.1) {
                        // Back wall - spotlight positioned above and in front
                        spotPos.y += 2;
                        spotPos.z -= 1.5;
                    } else if (position.rot.y > 0) {
                        // Left wall - spotlight positioned above and to the right
                        spotPos.y += 2;
                        spotPos.x += 1.5;
                    } else {
                        // Right wall - spotlight positioned above and to the left
                        spotPos.y += 2;
                        spotPos.x -= 1.5;
                    }
                    
                    // Calculate direction from spotlight to artwork center
                    const direction = position.pos.subtract(spotPos).normalize();
                    
                    // ✅ CREATE SPOTLIGHT WITH UNIQUE NAME AND ENSURE IT'S ADDED TO SCENE
                    const spotlightName = `artwork_spotlight_${index}`;
                    const spotlight = new BABYLON.SpotLight(spotlightName,
                        spotPos, direction,
                        Math.PI/6, 1, this.scene);
                    
                    // ✅ CONFIGURE SUBTLE LIGHTING
                    spotlight.intensity = 0.4;
                    spotlight.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
                    spotlight.specular = new BABYLON.Color3(0.8, 0.8, 0.8);
                    
                    // ✅ EXPLICITLY ADD TO SCENE AND SPOTLIGHTS ARRAY
                    this.scene.lights.push(spotlight);
                    this.spotLights.push(spotlight);
                    
                    // ✅ FORCE SCENE TO RECOGNIZE THE NEW LIGHT
                    this.scene.markAllMaterialsAsDirty(BABYLON.Material.LightDirtyFlag);
                    
                    console.log(`✅ Created spotlight ${index + 1}/${DEFAULT_ARTWORKS.length}: ${spotlightName} at position`, spotPos);
                    console.log(`   Total scene lights: ${this.scene.lights.length}, Total spotlights: ${this.spotLights.length}`);
                    
                    // Store artwork data
                    const artworkData = {
                        mesh: plane,
                        name: name,
                        author: author,
                        description: description,
                        material: material,
                        texture: texture,
                        spotlight: spotlight,
                        position: position,
                        isDefault: true,
                        imageURL: imageURL,
                        originalDimensions: { width: img.width, height: img.height },
                        displayDimensions: { width: width, height: height }
                    };
                    
                    this.artworks.push(artworkData);
                    this.updateInfo();
                    
                    // Position camera near first artwork
                    if (this.artworks.length === 1) {
                        setTimeout(() => {
                            this.camera.position = new BABYLON.Vector3(0, 1.6, 5);
                            this.camera.setTarget(new BABYLON.Vector3(0, 2, 9.8));
                        }, 500);
                    }
                    
                    console.log(`✅ Loaded: "${name}" by ${author} (${width.toFixed(1)}x${height.toFixed(1)} units)`);
                };
                
                img.onerror = () => {
                    console.error(`❌ Failed to load: ${name} from ${imageURL}`);
                    // Create fallback colored artwork
                    this.createFallbackArtwork(name, author, index);
                };
                
                img.src = imageURL;
            }
            
            createFallbackArtwork(name, author, index) {
                const position = this.artworkPositions[index];
                const colors = [
                    [0.8, 0.2, 0.2], [0.2, 0.4, 0.8], [0.9, 0.9, 0.3],
                    [0.2, 0.7, 0.3], [0.6, 0.2, 0.8], [0.9, 0.5, 0.2]
                ];
                const color = colors[index % colors.length];
                
                const plane = BABYLON.MeshBuilder.CreatePlane(`fallback_${index}`, 
                    { width: 3, height: 2 }, this.scene);
                
                plane.position = position.pos.clone();
                plane.rotation = position.rot.clone();
                
                const material = new BABYLON.StandardMaterial(`fallback_mat_${index}`, this.scene);
                material.diffuseColor = new BABYLON.Color3(...color);
                material.emissiveColor = new BABYLON.Color3(...color.map(c => c * 0.3));
                plane.material = material;
                
                // ✅ ENSURE FALLBACK ARTWORKS GET SPOTLIGHTS TOO
                const spotPos = position.pos.clone();
                
                if (Math.abs(position.rot.y) < 0.1) {
                    spotPos.y += 2;
                    spotPos.z -= 1.5;
                } else if (position.rot.y > 0) {
                    spotPos.y += 2;
                    spotPos.x += 1.5;
                } else {
                    spotPos.y += 2;
                    spotPos.x -= 1.5;
                }
                
                const direction = position.pos.subtract(spotPos).normalize();
                const spotlightName = `fallback_spotlight_${index}`;
                const spotlight = new BABYLON.SpotLight(spotlightName,
                    spotPos, direction, Math.PI/6, 1, this.scene);
                
                spotlight.intensity = 0.4;
                spotlight.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
                spotlight.specular = new BABYLON.Color3(0.8, 0.8, 0.8);
                
                // ✅ EXPLICITLY ADD TO SCENE
                this.scene.lights.push(spotlight);
                this.spotLights.push(spotlight);
                this.scene.markAllMaterialsAsDirty(BABYLON.Material.LightDirtyFlag);
                
                console.log(`✅ Created fallback spotlight ${index + 1}: ${spotlightName}`);
                
                this.artworks.push({
                    mesh: plane,
                    name: name + " (Fallback)",
                    author: author,
                    material: material,
                    spotlight: spotlight,
                    position: position,
                    isDefault: true
                });
                
                this.updateInfo();
                console.log(`⚠️ Created fallback for: ${name}`);
            }
            
            // UI Methods
            uploadArt() {
                document.getElementById('uploadModal').classList.add('show');
            }
            
            hideUpload() {
                document.getElementById('uploadModal').classList.remove('show');
            }
            
            selectFiles() {
                document.getElementById('fileInput').click();
            }
            
            resetCamera() {
                // ✅ RETURN TO HALL CENTER WITH QUATERNION RESET
                this.camera.position = new BABYLON.Vector3(0, 1.6, 0);
                this.camera.setTarget(new BABYLON.Vector3(0, 1.6, 5));
                
                // Reset quaternion states
                this.camera.rotationQuaternion = new BABYLON.Quaternion.Identity();
                this.touchRotationQuaternion = new BABYLON.Quaternion.Identity();
                
                // Reset gyro smoothed values
                this.smoothedYaw = 0;
                this.smoothedPitch = 0;
                
                this.showNotification('📍 Camera reset to hall center');
            }
            
            nextArtwork() {
                this.teleportToNextArtwork();
            }
            
            toggleLighting() {
                this.lightingBright = !this.lightingBright;
                
                if (this.lightingBright) {
                    // Bright mode
                    this.ambientLight.intensity = 1.2;
                    this.directionalLight.intensity = 0.9;
                    this.spotLights.forEach(light => light.intensity = 0.6); // Subtle but brighter
                } else {
                    // Normal mode  
                    this.ambientLight.intensity = 0.8;
                    this.directionalLight.intensity = 0.6;
                    this.spotLights.forEach(light => light.intensity = 0.4); // Subtle
                }
                
                this.showNotification(`💡 Lighting: ${this.lightingBright ? 'Bright' : 'Normal'} (subtle spotlights)`);
            }
            
            toggleGyro() {
                if (!this.isMobile()) {
                    this.showNotification('Gyroscope only available on mobile devices');
                    return;
                }
                
                if (!this.gyroSupported) {
                    this.showNotification('Gyroscope not supported on this device');
                    return;
                }
                
                if (this.gyroEnabled) {
                    this.gyroEnabled = false;
                    document.getElementById('gyroBtn').textContent = 'Enable Ground Gyro';
                    document.getElementById('calibrateBtn').style.display = 'none';
                    this.showNotification('Ground-parallel gyroscope disabled');
                    this.updateDebug("Gyro: Disabled");
                } else {
                    this.requestGyroPermission();
                }
            }
            
            clearGallery() {
                // Remove user artworks but keep defaults
                const userArtworks = this.artworks.filter(art => !art.isDefault);
                userArtworks.forEach(art => {
                    art.mesh.dispose();
                    art.material.dispose();
                    art.spotlight.dispose();
                });
                
                this.artworks = this.artworks.filter(art => art.isDefault);
                this.currentArtIndex = 0;
                
                this.showNotification(`🗑️ Cleared ${userArtworks.length} user artworks`);
                this.updateInfo();
            }
            
            // Utility methods
            isMobile() {
                return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
            
            showNotification(message) {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.classList.add('show');
                setTimeout(() => notification.classList.remove('show'), 3000);
            }
            
            updateDebug(message) {
                document.getElementById('debugPanel').innerHTML = message;
            }
            
            updateInfo() {
                const info = document.getElementById('info');
                if (this.artworks.length > 0) {
                    const defaultCount = this.artworks.filter(art => art.isDefault).length;
                    const userCount = this.artworks.filter(art => !art.isDefault).length;
                    const gyroStatus = this.isMobile() ? (this.gyroEnabled ? 'Ground Gyro ON' : 'Ground Gyro OFF') : 'Desktop Mode';
                    info.textContent = `${this.artworks.length} artworks (${defaultCount} default${userCount > 0 ? `, ${userCount} user` : ''}) • Double-tap to teleport • ${gyroStatus}`;
                } else {
                    info.textContent = 'Loading gallery... • Upload artwork or browse default collection';
                }
            }
        }
        
        // Initialize gallery with proper Babylon.js loading
        let app;
        window.addEventListener('DOMContentLoaded', async () => {
            try {
                // ✅ WAIT FOR BABYLON.JS TO LOAD BEFORE CREATING GALLERY
                await waitForBabylon();
                app = new EnhancedVirtualGallery();
            } catch (error) {
                console.error('Failed to initialize gallery:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ff4444;">
                        <h3>Loading Error</h3>
                        <p>${error.message}</p>
                        <button onclick="location.reload()" style="margin-top:10px;padding:8px 16px;background:#0078ff;color:white;border:none;border-radius:4px;cursor:pointer;">
                            Retry
                        </button>
                    </div>
                `;
            }
        });
    </script>
</body>
</html>